claims:
  - id: "001"
    type: contract
    statement: "The expression 2+2 evaluates to 4"
    criteria:
      - "Dies if 2+2 != 4 in Python"
      - "Dies if 2+2 != 4 in integer arithmetic"
      - "Dies if 2+2 == 5 (Orwellian test)"
    context:
      constraints: "Standard arithmetic, integer operands"
      approach: "Execute 2+2 in Python, compare result to 4"
    test:
      method: "Direct Python evaluation with multiple verification approaches"
      code: |
        result = 2 + 2
        is_four = (2 + 2 == 4)
        is_five = (2 + 2 == 5)
        all_passed = (result == 4) and is_four and (not is_five)
    observations:
      raw: |
        Test 1 - Direct evaluation: 2+2 = 4
          Criterion: Dies if 2+2 != 4
          Result: SURVIVED

        Test 2 - Comparison: (2+2 == 4) = True
          Criterion: Dies if False
          Result: SURVIVED

        Test 3 - Orwellian: (2+2 == 5) = False
          Criterion: Dies if 2+2 == 5
          Result: SURVIVED

        Test 4 - Type verification:
          type(2+2) = <class 'int'>
          2+2 is int: True
      unexpected: "None - arithmetic behaved as expected"
    verdict: SURVIVED
    reasoning: "All three kill criteria failed to kill the claim. 2+2 evaluates to exactly 4 in Python integer arithmetic."
    mutations:
      - "Does 2+2=4 hold in floating point? (potential precision issues)"
      - "Does 2+2=4 hold in modular arithmetic (mod 3)?"
      - "Does 2+2=4 hold across all programming languages?"
